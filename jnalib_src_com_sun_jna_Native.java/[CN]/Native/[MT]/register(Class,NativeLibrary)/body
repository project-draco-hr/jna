{
  Method[] methods=cls.getDeclaredMethods();
  List mlist=new ArrayList();
  for (int i=0; i < methods.length; i++) {
    if ((methods[i].getModifiers() & Modifier.NATIVE) != 0) {
      mlist.add(methods[i]);
    }
  }
  long[] handles=new long[mlist.size()];
  for (int i=0; i < handles.length; i++) {
    Method method=(Method)mlist.get(i);
    String sig="(";
    Class rtype=method.getReturnType();
    Class[] ptypes=method.getParameterTypes();
    long[] atypes=new long[ptypes.length];
    int[] cvt=new int[ptypes.length];
    int rcvt=getConversion(rtype);
    if (rcvt == CVT_UNSUPPORTED) {
      throw new IllegalArgumentException(rtype + " is not a supported return type (in method " + method.getName()+ " in "+ cls+ ")");
    }
    for (int t=0; t < ptypes.length; t++) {
      Class type=ptypes[t];
      sig+=getSignature(type);
      cvt[t]=getConversion(type);
      if (cvt[t] == CVT_UNSUPPORTED) {
        throw new IllegalArgumentException(type + " is not a supported argument type (in method " + method.getName()+ " in "+ cls+ ")");
      }
      if (cvt[t] == CVT_STRUCTURE_BYVAL || cvt[t] == CVT_DEFAULT) {
        atypes[t]=FFIType.get(type).peer;
      }
 else {
        atypes[t]=FFIType.get(Pointer.class).peer;
      }
    }
    sig+=")";
    sig+=getSignature(rtype);
    String name=method.getName();
    FunctionMapper mapper=(FunctionMapper)lib.getOptions().get(Library.OPTION_FUNCTION_MAPPER);
    if (mapper != null) {
      name=mapper.getFunctionName(lib,method);
    }
    Function f=lib.getFunction(name);
    try {
      handles[i]=registerMethod(cls,method.getName(),sig,cvt,atypes,rcvt,FFIType.get(rtype).peer,rtype,f.peer,f.callingConvention);
    }
 catch (    NoSuchMethodError e) {
      throw new UnsatisfiedLinkError("No method " + method.getName() + " with signature "+ sig+ " in "+ cls);
    }
  }
synchronized (registeredClasses) {
    registeredClasses.put(cls,handles);
    registeredLibraries.put(cls,lib);
  }
}
