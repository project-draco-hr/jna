{
  Object result=null;
  Object[] args={};
  if (inArgs != null) {
    args=new Object[inArgs.length];
    System.arraycopy(inArgs,0,args,0,args.length);
  }
  for (int i=0; i < args.length; i++) {
    Object arg=args[i];
    if (arg == null || isPrimitiveArray(arg.getClass())) {
      continue;
    }
    Class argClass=arg.getClass();
    if (arg instanceof Structure) {
      Structure struct=(Structure)arg;
      struct.write();
      args[i]=struct.getPointer();
    }
 else     if (arg instanceof ByReference) {
      args[i]=((ByReference)arg).getPointer();
    }
 else     if (arg instanceof Callback) {
      CallbackReference cbref=CallbackReference.getInstance((Callback)arg,callingConvention);
      args[i]=cbref.getTrampoline();
    }
 else     if (arg instanceof String) {
      args[i]=new NativeString((String)arg,false).getPointer();
    }
 else     if (arg instanceof WString) {
      args[i]=new NativeString(arg.toString(),true).getPointer();
    }
 else     if (arg instanceof NativeLong) {
      args[i]=((NativeLong)arg).asNativeValue();
    }
 else     if (arg instanceof Boolean) {
      args[i]=new Integer(Boolean.TRUE.equals(arg) ? -1 : 0);
    }
 else     if (isStructureArray(argClass)) {
      Structure[] ss=(Structure[])arg;
      if (ss.length == 0) {
        args[i]=null;
      }
 else       if (ss[0] == null) {
        Class type=argClass.getComponentType();
        try {
          Structure struct=(Structure)type.newInstance();
          int size=struct.size();
          Memory m=new Memory(size * ss.length);
          struct.useMemory(m);
          Structure[] tmp=struct.toArray(ss.length);
          for (int si=0; si < ss.length; si++) {
            ss[si]=tmp[si];
          }
        }
 catch (        Exception e) {
          throw new IllegalArgumentException("Can't instantiate " + type + ": "+ e);
        }
        args[i]=ss[0].getPointer();
      }
 else {
        Pointer base=ss[0].getPointer();
        int size=ss[0].size();
        for (int si=1; si < ss.length; si++) {
          try {
            Pointer p=base.share(size * si,size);
            if (ss[si].getPointer().peer != p.peer) {
              throw new RuntimeException();
            }
          }
 catch (          RuntimeException e) {
            String msg="Structure array elements must use" + " contiguous memory: " + si;
            throw new IllegalArgumentException(msg);
          }
        }
        args[i]=base;
      }
    }
 else     if (argClass.isArray()) {
      throw new IllegalArgumentException("Unsupported array type: " + argClass.getComponentType());
    }
  }
  if (returnType == Void.TYPE || returnType == Void.class) {
    invokeVoid(callingConvention,args);
  }
 else   if (returnType == Boolean.TYPE || returnType == Boolean.class) {
    result=new Boolean(invokeInt(callingConvention,args) != 0);
  }
 else   if (returnType == Byte.TYPE || returnType == Byte.class) {
    result=new Byte((byte)invokeInt(callingConvention,args));
  }
 else   if (returnType == Short.TYPE || returnType == Short.class) {
    result=new Short((short)invokeInt(callingConvention,args));
  }
 else   if (returnType == Integer.TYPE || returnType == Integer.class) {
    result=new Integer(invokeInt(callingConvention,args));
  }
 else   if (returnType == Long.TYPE || returnType == Long.class) {
    result=new Long(invokeLong(callingConvention,args));
  }
 else   if (returnType == NativeLong.class) {
    result=new NativeLong(NativeLong.SIZE == 8 ? invokeLong(callingConvention,args) : invokeInt(callingConvention,args));
  }
 else   if (returnType == Float.TYPE || returnType == Float.class) {
    result=new Float(invokeFloat(callingConvention,args));
  }
 else   if (returnType == Double.TYPE || returnType == Double.class) {
    result=new Double(invokeDouble(callingConvention,args));
  }
 else   if (returnType == String.class) {
    result=invokeString(args,false);
  }
 else   if (returnType == WString.class) {
    result=new WString(invokeString(args,true));
  }
 else   if (Pointer.class.isAssignableFrom(returnType)) {
    result=invokePointer(callingConvention,args);
  }
 else   if (Structure.class.isAssignableFrom(returnType)) {
    result=invokePointer(callingConvention,args);
    try {
      Structure s=(Structure)returnType.newInstance();
      s.useMemory((Pointer)result);
      s.read();
      result=s;
    }
 catch (    Exception e) {
      throw new IllegalArgumentException("Can't instantiate " + returnType + ": "+ e);
    }
  }
 else {
    throw new IllegalArgumentException("Unsupported return type " + returnType);
  }
  if (inArgs != null) {
    for (int i=0; i < inArgs.length; i++) {
      Object arg=inArgs[i];
      if (arg == null)       continue;
      if (arg instanceof Structure) {
        ((Structure)arg).read();
      }
 else       if (isStructureArray(arg.getClass())) {
        Structure[] ss=(Structure[])arg;
        for (int si=0; si < ss.length; si++) {
          ss[si].read();
        }
      }
    }
  }
  return result;
}
