{
  Object arg=args[index];
  if (arg != null) {
    Class type=arg.getClass();
    ToNativeConverter converter=null;
    if (NativeMapped.class.isAssignableFrom(type)) {
      converter=NativeMappedConverter.getInstance(type);
    }
 else     if (mapper != null) {
      converter=mapper.getToNativeConverter(type);
    }
    if (converter != null) {
      ToNativeContext context;
      if (invokingMethod != null) {
        context=new MethodParameterContext(this,args,index,invokingMethod);
      }
 else {
        context=new FunctionParameterContext(this,args,index);
      }
      arg=converter.toNative(arg,context);
    }
  }
  if (arg == null || isPrimitiveArray(arg.getClass())) {
    return arg;
  }
  Class argClass=arg.getClass();
  if (arg instanceof Structure) {
    Structure struct=(Structure)arg;
    struct.write();
    if (struct instanceof Structure.ByValue) {
      Class ptype=struct.getClass();
      if (invokingMethod != null) {
        Class[] ptypes=invokingMethod.getParameterTypes();
        if (isVarArgs(invokingMethod)) {
          if (index < ptypes.length - 1) {
            ptype=ptypes[index];
          }
 else {
            Class etype=ptypes[ptypes.length - 1].getComponentType();
            if (etype != Object.class) {
              ptype=etype;
            }
          }
        }
 else {
          ptype=ptypes[index];
        }
      }
      if (Structure.ByValue.class.isAssignableFrom(ptype)) {
        return struct;
      }
    }
    return struct.getPointer();
  }
 else   if (arg instanceof Callback) {
    return CallbackReference.getFunctionPointer((Callback)arg);
  }
 else   if (arg instanceof String) {
    return new NativeString((String)arg,false).getPointer();
  }
 else   if (arg instanceof WString) {
    return new NativeString(arg.toString(),true).getPointer();
  }
 else   if (arg instanceof Boolean) {
    return new Integer(Boolean.TRUE.equals(arg) ? -1 : 0);
  }
 else   if (String[].class == argClass) {
    return new StringArray((String[])arg);
  }
 else   if (WString[].class == argClass) {
    return new StringArray((WString[])arg);
  }
 else   if (Pointer[].class == argClass) {
    return new PointerArray((Pointer[])arg);
  }
 else   if (Structure[].class.isAssignableFrom(argClass)) {
    Structure[] ss=(Structure[])arg;
    Class type=argClass.getComponentType();
    boolean byRef=Structure.ByReference.class.isAssignableFrom(type);
    if (byRef) {
      Pointer[] pointers=new Pointer[ss.length + 1];
      for (int i=0; i < ss.length; i++) {
        pointers[i]=ss[i] != null ? ss[i].getPointer() : null;
      }
      return new PointerArray(pointers);
    }
 else     if (ss.length == 0) {
      throw new IllegalArgumentException("Structure array must have non-zero length");
    }
 else     if (ss[0] == null) {
      Structure struct=Structure.newInstance(type);
      int size=struct.size();
      Memory m=new Memory(size * ss.length);
      struct.useMemory(m);
      Structure[] tmp=struct.toArray(ss.length);
      for (int si=0; si < ss.length; si++) {
        ss[si]=tmp[si];
      }
      return ss[0].getPointer();
    }
 else {
      Pointer base=ss[0].getPointer();
      int size=ss[0].size();
      ss[0].write();
      for (int si=1; si < ss.length; si++) {
        if (ss[si].getPointer().peer != base.peer + size * si) {
          String msg="Structure array elements must use" + " contiguous memory (at element index " + si + ")";
          throw new IllegalArgumentException(msg);
        }
        ss[si].write();
      }
      return base;
    }
  }
 else   if (argClass.isArray()) {
    throw new IllegalArgumentException("Unsupported array argument type: " + argClass.getComponentType());
  }
  if (arg != null && !Native.isSupportedNativeType(arg.getClass())) {
    throw new IllegalArgumentException("Unsupported argument type " + arg.getClass().getName() + " at parameter "+ index+ " of function "+ getName());
  }
  return arg;
}
