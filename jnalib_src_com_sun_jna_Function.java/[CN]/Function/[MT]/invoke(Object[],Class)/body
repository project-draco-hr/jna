{
  Object result=null;
  if (returnType == null || returnType == void.class || returnType == Void.class) {
    invokeVoid(callingConvention,args);
    result=null;
  }
 else   if (returnType == boolean.class || returnType == Boolean.class) {
    result=valueOf(invokeInt(callingConvention,args) != 0);
  }
 else   if (returnType == byte.class || returnType == Byte.class) {
    result=new Byte((byte)invokeInt(callingConvention,args));
  }
 else   if (returnType == short.class || returnType == Short.class) {
    result=new Short((short)invokeInt(callingConvention,args));
  }
 else   if (returnType == char.class || returnType == Character.class) {
    result=new Character((char)invokeInt(callingConvention,args));
  }
 else   if (returnType == int.class || returnType == Integer.class) {
    result=new Integer(invokeInt(callingConvention,args));
  }
 else   if (returnType == long.class || returnType == Long.class) {
    result=new Long(invokeLong(callingConvention,args));
  }
 else   if (returnType == float.class || returnType == Float.class) {
    result=new Float(invokeFloat(callingConvention,args));
  }
 else   if (returnType == double.class || returnType == Double.class) {
    result=new Double(invokeDouble(callingConvention,args));
  }
 else   if (returnType == String.class) {
    result=invokeString(callingConvention,args,false);
  }
 else   if (returnType == WString.class) {
    String s=invokeString(callingConvention,args,true);
    if (s != null) {
      result=new WString(s);
    }
  }
 else   if (Pointer.class.isAssignableFrom(returnType)) {
    result=invokePointer(callingConvention,args);
  }
 else   if (Structure.class.isAssignableFrom(returnType)) {
    if (Structure.ByValue.class.isAssignableFrom(returnType)) {
      Structure s=invokeStructure(callingConvention,args,Structure.newInstance(returnType));
      if (s.getAutoRead()) {
        s.read();
      }
      result=s;
    }
 else {
      result=invokePointer(callingConvention,args);
      if (result != null) {
        Structure s=Structure.newInstance(returnType);
        s.useMemory((Pointer)result);
        if (s.getAutoRead()) {
          s.read();
        }
        result=s;
      }
    }
  }
 else   if (Callback.class.isAssignableFrom(returnType)) {
    result=invokePointer(callingConvention,args);
    if (result != null) {
      result=CallbackReference.getCallback(returnType,(Pointer)result);
    }
  }
 else   if (returnType == String[].class) {
    Pointer p=invokePointer(callingConvention,args);
    if (p != null) {
      result=p.getStringArray(0);
    }
  }
 else   if (returnType == WString[].class) {
    Pointer p=invokePointer(callingConvention,args);
    if (p != null) {
      String[] arr=p.getStringArray(0,true);
      WString[] warr=new WString[arr.length];
      for (int i=0; i < arr.length; i++) {
        warr[i]=new WString(arr[i]);
      }
      result=warr;
    }
  }
 else   if (returnType == Pointer[].class) {
    Pointer p=invokePointer(callingConvention,args);
    if (p != null) {
      result=p.getPointerArray(0);
    }
  }
 else {
    throw new IllegalArgumentException("Unsupported return type " + returnType + " in function "+ getName());
  }
  return result;
}
