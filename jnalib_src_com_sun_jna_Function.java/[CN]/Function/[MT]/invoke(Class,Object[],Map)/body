{
  Object[] args={};
  if (inArgs != null) {
    if (inArgs.length > MAX_NARGS) {
      throw new UnsupportedOperationException("Maximum argument count is " + MAX_NARGS);
    }
    args=new Object[inArgs.length];
    System.arraycopy(inArgs,0,args,0,args.length);
  }
  TypeMapper mapper=(TypeMapper)options.get(Library.OPTION_TYPE_MAPPER);
  Method invokingMethod=(Method)options.get(Library.OPTION_INVOKING_METHOD);
  for (int i=0; i < args.length; i++) {
    args[i]=convertArgument(args,i,invokingMethod,mapper);
  }
  Class nativeType=returnType;
  FromNativeConverter resultConverter=null;
  if (NativeMapped.class.isAssignableFrom(returnType)) {
    NativeMappedConverter tc=new NativeMappedConverter(returnType);
    resultConverter=tc;
    nativeType=tc.nativeType();
  }
 else   if (mapper != null) {
    resultConverter=mapper.getFromNativeConverter(returnType);
    if (resultConverter != null) {
      nativeType=resultConverter.nativeType();
    }
  }
  Object result=invoke(args,nativeType);
  if (resultConverter != null) {
    FromNativeContext context;
    if (invokingMethod != null) {
      context=new MethodResultContext(returnType,this,inArgs,invokingMethod);
    }
 else {
      context=new FunctionResultContext(returnType,this,inArgs);
    }
    result=resultConverter.fromNative(result,context);
  }
  if (inArgs != null) {
    for (int i=0; i < inArgs.length; i++) {
      Object arg=inArgs[i];
      if (arg == null)       continue;
      if (arg instanceof Structure) {
        ((Structure)arg).read();
      }
 else       if (args[i] instanceof StringArray) {
        ((StringArray)args[i]).read();
      }
 else       if (args[i] instanceof PointerArray) {
        ((PointerArray)args[i]).read();
      }
 else       if (Structure[].class.isAssignableFrom(arg.getClass())) {
        Structure[] ss=(Structure[])arg;
        for (int si=0; si < ss.length; si++) {
          ss[si].read();
        }
      }
    }
  }
  return result;
}
