{
  Object result=null;
  if (inArgs != null && inArgs.length > 0) {
    Object lastArg=inArgs[inArgs.length - 1];
    if (lastArg != null && Object[].class == lastArg.getClass()) {
      Object[] varArgs=(Object[])lastArg;
      Object[] fullArgs=new Object[inArgs.length + varArgs.length];
      System.arraycopy(inArgs,0,fullArgs,0,inArgs.length - 1);
      System.arraycopy(varArgs,0,fullArgs,inArgs.length - 1,varArgs.length);
      fullArgs[fullArgs.length - 1]=null;
      inArgs=fullArgs;
    }
  }
  Object[] args={};
  if (inArgs != null) {
    if (inArgs.length > MAX_NARGS) {
      throw new UnsupportedOperationException("Maximum argument count is " + MAX_NARGS);
    }
    args=new Object[inArgs.length];
    System.arraycopy(inArgs,0,args,0,args.length);
  }
  TypeMapper mapper=(TypeMapper)options.get(Library.OPTION_TYPE_MAPPER);
  for (int i=0; i < args.length; i++) {
    Object arg=args[i];
    if (arg != null && mapper != null) {
      ArgumentConverter converter=mapper.getArgumentConverter(arg.getClass());
      if (converter != null) {
        args[i]=arg=converter.toNative(arg);
      }
    }
    if (arg == null || isPrimitiveArray(arg.getClass())) {
      continue;
    }
    Class argClass=arg.getClass();
    if (arg instanceof Structure) {
      Structure struct=(Structure)arg;
      struct.write();
      args[i]=struct.getPointer();
    }
 else     if (arg instanceof ByReference) {
      args[i]=((ByReference)arg).getPointer();
    }
 else     if (arg instanceof Callback) {
      CallbackReference cbref=CallbackReference.getInstance((Callback)arg,callingConvention);
      args[i]=cbref.getTrampoline();
    }
 else     if (arg instanceof String) {
      args[i]=new NativeString((String)arg,false).getPointer();
    }
 else     if (arg instanceof WString) {
      args[i]=new NativeString(arg.toString(),true).getPointer();
    }
 else     if (arg instanceof NativeLong) {
      args[i]=((NativeLong)arg).asNativeValue();
    }
 else     if (arg instanceof Boolean) {
      args[i]=new Integer(Boolean.TRUE.equals(arg) ? -1 : 0);
    }
 else     if (String[].class.equals(argClass)) {
      args[i]=new StringArray((String[])arg);
    }
 else     if (isStructureArray(argClass)) {
      Structure[] ss=(Structure[])arg;
      if (ss.length == 0) {
        args[i]=null;
      }
 else       if (ss[0] == null) {
        Class type=argClass.getComponentType();
        try {
          Structure struct=(Structure)type.newInstance();
          int size=struct.size();
          Memory m=new Memory(size * ss.length);
          struct.useMemory(m);
          Structure[] tmp=struct.toArray(ss.length);
          for (int si=0; si < ss.length; si++) {
            ss[si]=tmp[si];
          }
        }
 catch (        InstantiationException e) {
          throw new IllegalArgumentException("Instantiation of " + type + " failed: "+ e);
        }
catch (        IllegalAccessException e) {
          throw new IllegalArgumentException("Not allowed to instantiate " + type + ": "+ e);
        }
        args[i]=ss[0].getPointer();
      }
 else {
        Pointer base=ss[0].getPointer();
        int size=ss[0].size();
        for (int si=1; si < ss.length; si++) {
          try {
            Pointer p=base.share(size * si,size);
            if (ss[si].getPointer().peer != p.peer) {
              throw new RuntimeException();
            }
          }
 catch (          RuntimeException e) {
            String msg="Structure array elements must use" + " contiguous memory: " + si;
            throw new IllegalArgumentException(msg);
          }
        }
        args[i]=base;
      }
    }
 else     if (arg instanceof ByteBuffer && !((ByteBuffer)arg).isDirect()) {
      ByteBuffer buf=(ByteBuffer)arg;
      if (buf.hasArray()) {
        args[i]=buf.array();
      }
 else {
        throw new IllegalArgumentException("Unsupported non-direct ByteBuffer with no array");
      }
    }
 else     if (argClass.isArray()) {
      throw new IllegalArgumentException("Unsupported array argument type: " + argClass.getComponentType());
    }
  }
  Class nativeType=returnType;
  ResultConverter resultConverter=null;
  if (mapper != null) {
    resultConverter=mapper.getResultConverter(returnType);
    if (resultConverter != null) {
      nativeType=resultConverter.nativeType();
    }
  }
  if (nativeType == null || nativeType == void.class || nativeType == Void.class) {
    invokeVoid(callingConvention,args);
  }
 else   if (nativeType == boolean.class || nativeType == Boolean.class) {
    result=new Boolean(invokeInt(callingConvention,args) != 0);
  }
 else   if (nativeType == byte.class || nativeType == Byte.class) {
    result=new Byte((byte)invokeInt(callingConvention,args));
  }
 else   if (nativeType == short.class || nativeType == Short.class) {
    result=new Short((short)invokeInt(callingConvention,args));
  }
 else   if (nativeType == int.class || nativeType == Integer.class) {
    result=new Integer(invokeInt(callingConvention,args));
  }
 else   if (nativeType == long.class || nativeType == Long.class) {
    result=new Long(invokeLong(callingConvention,args));
  }
 else   if (nativeType == NativeLong.class) {
    result=new NativeLong(NativeLong.SIZE == 8 ? invokeLong(callingConvention,args) : invokeInt(callingConvention,args));
  }
 else   if (nativeType == float.class || nativeType == Float.class) {
    result=new Float(invokeFloat(callingConvention,args));
  }
 else   if (nativeType == double.class || nativeType == Double.class) {
    result=new Double(invokeDouble(callingConvention,args));
  }
 else   if (nativeType == String.class) {
    result=invokeString(args,false);
  }
 else   if (nativeType == WString.class) {
    result=new WString(invokeString(args,true));
  }
 else   if (Pointer.class.isAssignableFrom(nativeType)) {
    result=invokePointer(callingConvention,args);
  }
 else   if (Structure.class.isAssignableFrom(nativeType)) {
    result=invokePointer(callingConvention,args);
    if (result != null) {
      try {
        Structure s=(Structure)nativeType.newInstance();
        s.useMemory((Pointer)result);
        s.read();
        result=s;
      }
 catch (      InstantiationException e) {
        throw new IllegalArgumentException("Instantiation of " + nativeType + " failed: "+ e);
      }
catch (      IllegalAccessException e) {
        throw new IllegalArgumentException("Not allowed to instantiate " + nativeType + ": "+ e);
      }
    }
  }
 else {
    throw new IllegalArgumentException("Unsupported return type " + nativeType);
  }
  if (resultConverter != null) {
    ResultContext context=new FunctionResultContext(returnType,this,inArgs);
    result=resultConverter.fromNative(result,context);
  }
  if (inArgs != null) {
    for (int i=0; i < inArgs.length; i++) {
      Object arg=inArgs[i];
      if (arg == null)       continue;
      if (arg instanceof Structure) {
        ((Structure)arg).read();
      }
 else       if (String[].class == arg.getClass()) {
        StringArray buf=(StringArray)args[i];
        String[] array=(String[])arg;
        for (int si=0; si < array.length; si++) {
          array[si]=buf.getPointer(si * Pointer.SIZE).getString(0,false);
        }
      }
 else       if (isStructureArray(arg.getClass())) {
        Structure[] ss=(Structure[])arg;
        for (int si=0; si < ss.length; si++) {
          ss[si].read();
        }
      }
    }
  }
  return result;
}
