{
  GDI32 gdi=GDI32.INSTANCE;
  PathIterator pi=area.getPathIterator(null);
  int mode=pi.getWindingRule() == PathIterator.WIND_NON_ZERO ? GDI32.WINDING : GDI32.ALTERNATE;
  float[] coords=new float[6];
  List points=new ArrayList();
  int size=0;
  List sizes=new ArrayList();
  while (!pi.isDone()) {
    int type=pi.currentSegment(coords);
    if (type == PathIterator.SEG_MOVETO) {
      size=1;
      points.add(new POINT((int)coords[0],(int)coords[1]));
    }
 else     if (type == PathIterator.SEG_LINETO) {
      ++size;
      points.add(new POINT((int)coords[0],(int)coords[1]));
    }
 else     if (type == PathIterator.SEG_CLOSE) {
      sizes.add(new Integer(size));
    }
 else {
      throw new RuntimeException("Area is not polygonal: " + area);
    }
    pi.next();
  }
  POINT[] lppt=(POINT[])new POINT().toArray(points.size());
  POINT[] pts=(POINT[])points.toArray(new POINT[points.size()]);
  for (int i=0; i < lppt.length; i++) {
    lppt[i].x=pts[i].x;
    lppt[i].y=pts[i].y;
  }
  int[] counts=new int[sizes.size()];
  for (int i=0; i < counts.length; i++) {
    counts[i]=((Integer)sizes.get(i)).intValue();
  }
  HRGN hrgn=gdi.CreatePolyPolygonRgn(lppt,counts,counts.length,mode);
  setWindowRegion(w,hrgn);
}
