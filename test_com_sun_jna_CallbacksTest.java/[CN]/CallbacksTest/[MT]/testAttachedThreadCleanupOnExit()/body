{
  final Set threads=new HashSet();
  final int[] called={0};
  TestLibrary.VoidCallback cb=new TestLibrary.VoidCallback(){
    public void callback(){
      threads.add(new WeakReference(Thread.currentThread()));
      if (++called[0] == 1) {
        Thread.currentThread().setName("Thread to be cleaned up");
      }
      Native.detach(false);
    }
  }
;
  CallbackThreadInitializer asDaemon=new CallbackThreadInitializer(true);
  callThreadedCallback(cb,asDaemon,1,0,called);
  while (threads.size() == 0) {
    Thread.sleep(10);
  }
  long start=System.currentTimeMillis();
  WeakReference ref=(WeakReference)threads.iterator().next();
  while (ref.get() != null) {
    System.gc();
    Thread.sleep(10);
    if (System.currentTimeMillis() - start > 10000) {
      Thread t=(Thread)ref.get();
      fail("Timed out waiting for attached thread to be detached on exit and disposed: " + t + " alive: "+ t.isAlive()+ " daemon "+ t.isDaemon());
    }
  }
}
