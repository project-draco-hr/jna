{
  final int[] called={0};
  final Set threads=new HashSet();
  final int COUNT=5;
  TestLibrary.VoidCallback cb=new TestLibrary.VoidCallback(){
    public void callback(){
      threads.add(Thread.currentThread());
      int count=called[0] + 1;
      if (count == 1) {
        Thread.currentThread().setName("Native thread for " + getName());
        Native.detach(false);
      }
 else       if (count == COUNT) {
        Native.detach(true);
      }
      called[0]=count;
    }
  }
;
  callThreadedCallback(cb,null,COUNT,100,called);
  assertEquals("Multiple callbacks in the same native thread should use the same Thread mapping: " + threads,1,threads.size());
  Thread thread=(Thread)threads.iterator().next();
  long start=System.currentTimeMillis();
  while (thread.isAlive()) {
    System.gc();
    Thread.sleep(10);
    if (System.currentTimeMillis() - start > THREAD_TIMEOUT) {
      fail("Timed out waiting for native thread " + thread + " to finish");
    }
  }
}
