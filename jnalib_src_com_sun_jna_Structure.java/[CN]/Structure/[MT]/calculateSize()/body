{
  structAlignment=1;
  int calculatedSize=0;
  Field[] fields=getClass().getFields();
  if (REVERSE_FIELDS) {
    for (int i=0; i < fields.length / 2; i++) {
      int idx=fields.length - 1 - i;
      Field tmp=fields[i];
      fields[i]=fields[idx];
      fields[idx]=tmp;
    }
  }
  for (int i=0; i < fields.length; i++) {
    Field field=fields[i];
    int modifiers=field.getModifiers();
    if (Modifier.isStatic(modifiers) || !Modifier.isPublic(modifiers))     continue;
    Class type=field.getType();
    StructField structField=new StructField();
    structField.isVolatile=Modifier.isVolatile(modifiers);
    structField.field=field;
    structField.name=field.getName();
    structField.type=type;
    int fieldAlignment=1;
    try {
      Object value=field.get(this);
      if (value == null) {
        if (Structure.class.isAssignableFrom(type)) {
          try {
            value=type.newInstance();
            field.set(this,value);
          }
 catch (          InstantiationException e) {
            String msg="Can't determine size of nested structure: " + e.getMessage();
            throw new IllegalArgumentException(msg);
          }
        }
 else         if (type.isArray()) {
          return CALCULATE_SIZE;
        }
      }
      Class nativeType=type;
      if (NativeMapped.class.isAssignableFrom(type)) {
        NativeMappedConverter tc=new NativeMappedConverter(type);
        value=tc.defaultValue();
        nativeType=tc.nativeType();
        structField.writeConverter=tc;
        structField.readConverter=tc;
        structField.context=new StructureReadContext(type,this);
        field.set(this,value);
      }
 else       if (typeMapper != null) {
        ToNativeConverter writeConverter=typeMapper.getToNativeConverter(type);
        FromNativeConverter readConverter=typeMapper.getFromNativeConverter(type);
        if (writeConverter != null && readConverter != null) {
          value=writeConverter.toNative(value);
          nativeType=value != null ? value.getClass() : Pointer.class;
          structField.writeConverter=writeConverter;
          structField.readConverter=readConverter;
          structField.context=new StructureReadContext(type,this);
        }
 else         if (writeConverter != null || readConverter != null) {
          String msg="Structures require bidirectional type conversion for " + type;
          throw new IllegalArgumentException(msg);
        }
      }
      structField.size=getNativeSize(nativeType,value);
      fieldAlignment=getNativeAlignment(nativeType,value,i == 0);
    }
 catch (    IllegalAccessException e) {
    }
    structAlignment=Math.max(structAlignment,fieldAlignment);
    if ((calculatedSize % fieldAlignment) != 0) {
      calculatedSize+=fieldAlignment - (calculatedSize % fieldAlignment);
    }
    structField.offset=calculatedSize;
    calculatedSize+=structField.size;
    structFields.put(structField.name,structField);
  }
  if (calculatedSize > 0) {
    return calculateAlignedSize(calculatedSize);
  }
  throw new IllegalArgumentException("Structure " + getClass() + " has unknown size (ensure "+ "all fields are public)");
}
