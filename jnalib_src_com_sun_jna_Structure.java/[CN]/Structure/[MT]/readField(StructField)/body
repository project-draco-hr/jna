{
  int offset=structField.offset;
  Class nativeType=structField.type;
  FromNativeConverter readConverter=structField.readConverter;
  if (readConverter != null) {
    nativeType=readConverter.nativeType();
  }
  Object result=null;
  if (Structure.class.isAssignableFrom(nativeType)) {
    Structure s=(Structure)getField(structField);
    if (ByReference.class.isAssignableFrom(nativeType)) {
      s=updateStructureByReference(nativeType,s,memory.getPointer(offset));
    }
 else {
      s.useMemory(memory,offset);
      s.read();
    }
    result=s;
  }
 else   if (nativeType == boolean.class || nativeType == Boolean.class) {
    result=Boolean.valueOf(memory.getInt(offset) != 0);
  }
 else   if (nativeType == byte.class || nativeType == Byte.class) {
    result=new Byte(memory.getByte(offset));
  }
 else   if (nativeType == short.class || nativeType == Short.class) {
    result=new Short(memory.getShort(offset));
  }
 else   if (nativeType == char.class || nativeType == Character.class) {
    result=new Character(memory.getChar(offset));
  }
 else   if (nativeType == int.class || nativeType == Integer.class) {
    result=new Integer(memory.getInt(offset));
  }
 else   if (nativeType == long.class || nativeType == Long.class) {
    result=new Long(memory.getLong(offset));
  }
 else   if (nativeType == float.class || nativeType == Float.class) {
    result=new Float(memory.getFloat(offset));
  }
 else   if (nativeType == double.class || nativeType == Double.class) {
    result=new Double(memory.getDouble(offset));
  }
 else   if (nativeType == Pointer.class) {
    result=memory.getPointer(offset);
  }
 else   if (nativeType == String.class) {
    Pointer p=memory.getPointer(offset);
    result=p != null ? p.getString(0) : null;
  }
 else   if (nativeType == WString.class) {
    Pointer p=memory.getPointer(offset);
    result=p != null ? new WString(p.getString(0,true)) : null;
  }
 else   if (Callback.class.isAssignableFrom(nativeType)) {
    Pointer fp=memory.getPointer(offset);
    if (fp == null) {
      result=null;
    }
 else {
      Callback cb=(Callback)getField(structField);
      Pointer oldfp=CallbackReference.getFunctionPointer(cb);
      if (!fp.equals(oldfp)) {
        cb=CallbackReference.getCallback(nativeType,fp);
      }
      result=cb;
    }
  }
 else   if (nativeType.isArray()) {
    Class cls=nativeType.getComponentType();
    int length=0;
    Object o=getField(structField);
    if (o == null) {
      throw new IllegalStateException("Array field in Structure not initialized");
    }
    length=Array.getLength(o);
    result=o;
    if (cls == byte.class) {
      memory.read(offset,(byte[])result,0,length);
    }
 else     if (cls == short.class) {
      memory.read(offset,(short[])result,0,length);
    }
 else     if (cls == char.class) {
      memory.read(offset,(char[])result,0,length);
    }
 else     if (cls == int.class) {
      memory.read(offset,(int[])result,0,length);
    }
 else     if (cls == long.class) {
      memory.read(offset,(long[])result,0,length);
    }
 else     if (cls == float.class) {
      memory.read(offset,(float[])result,0,length);
    }
 else     if (cls == double.class) {
      memory.read(offset,(double[])result,0,length);
    }
 else     if (Pointer.class.isAssignableFrom(cls)) {
      memory.read(offset,(Pointer[])result,0,length);
    }
 else     if (Structure.class.isAssignableFrom(cls) && ByReference.class.isAssignableFrom(cls)) {
      Structure[] sarray=(Structure[])result;
      Pointer[] parray=memory.getPointerArray(offset,sarray.length);
      for (int i=0; i < sarray.length; i++) {
        sarray[i]=updateStructureByReference(cls,sarray[i],parray[i]);
      }
    }
 else {
      throw new IllegalArgumentException("Array of " + cls + " not supported");
    }
  }
 else {
    throw new IllegalArgumentException("Unsupported field type \"" + nativeType + "\"");
  }
  if (readConverter != null) {
    result=readConverter.fromNative(result,structField.context);
  }
  setField(structField,result);
  return result;
}
