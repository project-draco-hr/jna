{
  int offset=structField.offset;
  Class nativeType=structField.type;
  FromNativeConverter readConverter=structField.readConverter;
  if (readConverter != null) {
    nativeType=readConverter.nativeType();
  }
  Object result=null;
  if (Structure.class.isAssignableFrom(nativeType)) {
    Structure s=null;
    try {
      s=(Structure)structField.field.get(this);
      s.useMemory(memory,offset);
      s.read();
    }
 catch (    IllegalAccessException e) {
    }
    result=s;
  }
 else   if (nativeType == byte.class || nativeType == Byte.class) {
    result=new Byte(memory.getByte(offset));
  }
 else   if (nativeType == short.class || nativeType == Short.class) {
    result=new Short(memory.getShort(offset));
  }
 else   if (nativeType == char.class || nativeType == Character.class) {
    result=new Character(memory.getChar(offset));
  }
 else   if (nativeType == int.class || nativeType == Integer.class) {
    result=new Integer(memory.getInt(offset));
  }
 else   if (nativeType == long.class || nativeType == Long.class) {
    result=new Long(memory.getLong(offset));
  }
 else   if (nativeType == float.class || nativeType == Float.class) {
    result=new Float(memory.getFloat(offset));
  }
 else   if (nativeType == double.class || nativeType == Double.class) {
    result=new Double(memory.getDouble(offset));
  }
 else   if (nativeType == Pointer.class) {
    result=memory.getPointer(offset);
  }
 else   if (nativeType == String.class) {
    Pointer p=memory.getPointer(offset);
    result=p != null ? p.getString(0) : null;
  }
 else   if (nativeType == WString.class) {
    Pointer p=memory.getPointer(offset);
    result=p != null ? new WString(p.getString(0,true)) : null;
  }
 else   if (Callback.class.isAssignableFrom(nativeType)) {
    Pointer fp=memory.getPointer(offset);
    if (fp == null) {
      result=null;
    }
 else     try {
      Callback cb=(Callback)structField.field.get(this);
      Pointer oldfp=CallbackReference.getFunctionPointer(cb);
      if (!fp.equals(oldfp)) {
        cb=CallbackReference.getCallback(nativeType,fp);
      }
      result=cb;
    }
 catch (    IllegalArgumentException e) {
      return;
    }
catch (    IllegalAccessException e) {
      return;
    }
  }
 else   if (nativeType.isArray()) {
    Class cls=nativeType.getComponentType();
    int length=0;
    try {
      Object o=structField.field.get(this);
      if (o == null) {
        throw new IllegalStateException("Structure array field not initialized");
      }
      length=Array.getLength(o);
    }
 catch (    IllegalArgumentException e) {
    }
catch (    IllegalAccessException e) {
    }
    if (cls == byte.class) {
      result=memory.getByteArray(offset,length);
    }
 else     if (cls == short.class) {
      result=memory.getShortArray(offset,length);
    }
 else     if (cls == char.class) {
      result=memory.getCharArray(offset,length);
    }
 else     if (cls == int.class) {
      result=memory.getIntArray(offset,length);
    }
 else     if (cls == long.class) {
      result=memory.getLongArray(offset,length);
    }
 else     if (cls == float.class) {
      result=memory.getFloatArray(offset,length);
    }
 else     if (cls == double.class) {
      result=memory.getDoubleArray(offset,length);
    }
 else     if (Pointer.class.isAssignableFrom(cls)) {
      result=memory.getPointerArray(offset,length);
    }
 else {
      throw new IllegalArgumentException("Array of " + cls + " not supported");
    }
  }
 else {
    throw new IllegalArgumentException("Unsupported field type \"" + nativeType + "\"");
  }
  if (readConverter != null) {
    result=readConverter.fromNative(result,structField.context);
  }
  try {
    structField.field.set(this,result);
  }
 catch (  Exception e) {
    throw new RuntimeException("Exception setting field \"" + structField.name + "\" to "+ result+ ": "+ e,e);
  }
}
