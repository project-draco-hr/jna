{
  int length=0;
  length=Array.getLength(o);
  Object result=o;
  if (cls == byte.class) {
    memory.read(offset,(byte[])result,0,length);
  }
 else   if (cls == short.class) {
    memory.read(offset,(short[])result,0,length);
  }
 else   if (cls == char.class) {
    memory.read(offset,(char[])result,0,length);
  }
 else   if (cls == int.class) {
    memory.read(offset,(int[])result,0,length);
  }
 else   if (cls == long.class) {
    memory.read(offset,(long[])result,0,length);
  }
 else   if (cls == float.class) {
    memory.read(offset,(float[])result,0,length);
  }
 else   if (cls == double.class) {
    memory.read(offset,(double[])result,0,length);
  }
 else   if (Pointer.class.isAssignableFrom(cls)) {
    memory.read(offset,(Pointer[])result,0,length);
  }
 else   if (Structure.class.isAssignableFrom(cls)) {
    Structure[] sarray=(Structure[])result;
    if (ByReference.class.isAssignableFrom(cls)) {
      Pointer[] parray=memory.getPointerArray(offset,sarray.length);
      for (int i=0; i < sarray.length; i++) {
        sarray[i]=updateStructureByReference(cls,sarray[i],parray[i]);
      }
    }
 else {
      for (int i=0; i < sarray.length; i++) {
        if (sarray[i] == null) {
          sarray[i]=newInstance(cls);
        }
        sarray[i].useMemory(memory,offset + i * sarray[i].size());
        sarray[i].read();
      }
    }
  }
 else   if (NativeMapped.class.isAssignableFrom(cls)) {
    NativeMapped[] array=(NativeMapped[])result;
    NativeMappedConverter tc=NativeMappedConverter.getInstance(cls);
    int size=getNativeSize(result.getClass(),result) / array.length;
    for (int i=0; i < array.length; i++) {
      Object value=readValue(offset + size * i,tc.nativeType(),array[i]);
      array[i]=(NativeMapped)tc.fromNative(value,new FromNativeContext(cls));
    }
  }
 else {
    throw new IllegalArgumentException("Array of " + cls + " not supported");
  }
}
