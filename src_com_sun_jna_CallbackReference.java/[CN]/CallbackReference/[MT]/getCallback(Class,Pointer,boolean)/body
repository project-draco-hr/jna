{
  if (p == null) {
    return null;
  }
  if (!type.isInterface())   throw new IllegalArgumentException("Callback type must be an interface");
  Map map=direct ? directCallbackMap : callbackMap;
synchronized (callbackMap) {
    Callback cb=null;
    Reference ref=(Reference)pointerCallbackMap.get(p);
    if (ref != null) {
      cb=(Callback)ref.get();
      if (cb != null && !type.isAssignableFrom(cb.getClass())) {
        throw new IllegalStateException("Pointer " + p + " already mapped to "+ cb);
      }
      return cb;
    }
    int ctype=AltCallingConvention.class.isAssignableFrom(type) ? Function.ALT_CONVENTION : Function.C_CONVENTION;
    Map foptions=new HashMap(Native.getLibraryOptions(type));
    foptions.put(Function.OPTION_INVOKING_METHOD,getCallbackMethod(type));
    NativeFunctionHandler h=new NativeFunctionHandler(p,ctype,foptions);
    cb=(Callback)Proxy.newProxyInstance(type.getClassLoader(),new Class[]{type},h);
    map.put(cb,null);
    pointerCallbackMap.put(p,new WeakReference(cb));
    return cb;
  }
}
