{
  File dir=file;
  if (!dir.isDirectory()) {
    recursive=false;
    dir=file.getParentFile();
  }
  while (dir != null && !dir.exists()) {
    recursive=true;
    dir=dir.getParentFile();
  }
  if (dir == null) {
    throw new FileNotFoundException("No ancestor found for " + file);
  }
  Kernel32 klib=Kernel32.INSTANCE;
  int mask=Kernel32.FILE_SHARE_READ | Kernel32.FILE_SHARE_WRITE | Kernel32.FILE_SHARE_DELETE;
  int flags=Kernel32.FILE_FLAG_BACKUP_SEMANTICS | Kernel32.FILE_FLAG_OVERLAPPED;
  Pointer handle=klib.CreateFileA(file.getAbsolutePath(),Kernel32.FILE_LIST_DIRECTORY,mask,null,Kernel32.OPEN_EXISTING,flags,null);
  if (Kernel32.INVALID_HANDLE_VALUE.equals(handle)) {
    throw new IOException("Unable to open " + file + " ("+ klib.GetLastError()+ ")");
  }
  int notifyMask=convertMask(eventMask);
  FileInfo finfo=new FileInfo(file,handle,notifyMask,recursive);
  fileMap.put(file,finfo);
  handleMap.put(handle,finfo);
  port=klib.CreateIoCompletionPort(handle,port,handle,0);
  if (Kernel32.INVALID_HANDLE_VALUE.equals(port)) {
    throw new IOException("Unable to create I/O Completion port " + "for " + file + " ("+ klib.GetLastError()+ ")");
  }
  if (!klib.ReadDirectoryChangesW(handle,finfo.info,finfo.info.size(),recursive,notifyMask,finfo.infoLength,finfo.overlapped,null)) {
    throw new IOException("ReadDirectoryChangesW failed on " + finfo.file + ":"+ finfo.handle+ " ("+ klib.GetLastError()+ ")");
  }
  if (watcher == null) {
    watcher=new Thread("W32 File Monitor"){
      public void run(){
        FileInfo finfo;
        while ((finfo=waitForChange()) != null) {
          try {
            handleChanges(finfo);
          }
 catch (          IOException e) {
            e.printStackTrace();
          }
        }
      }
    }
;
    watcher.setDaemon(true);
    watcher.start();
  }
}
