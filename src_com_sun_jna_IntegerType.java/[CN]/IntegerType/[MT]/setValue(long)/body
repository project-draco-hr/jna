{
  long truncated=value;
  this.value=value;
switch (size) {
case 1:
    truncated=(byte)value;
  this.number=new Byte((byte)value);
break;
case 2:
truncated=(short)value;
this.number=new Short((short)value);
break;
case 4:
truncated=(int)value;
this.number=new Integer((int)value);
break;
case 8:
this.number=new Long(value);
break;
default :
throw new IllegalArgumentException("Unsupported size: " + size);
}
if (size < 8) {
long mask=~((1L << (size * 8)) - 1);
if ((value < 0 && truncated != value) || (value >= 0 && (mask & value) != 0)) {
throw new IllegalArgumentException("Argument value 0x" + Long.toHexString(value) + " exceeds native capacity ("+ size+ " bytes) mask=0x"+ Long.toHexString(mask));
}
}
}
