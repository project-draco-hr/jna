{
  super(callback);
  Class type=callback.getClass();
  Class[] ifaces=type.getInterfaces();
  for (int i=0; i < ifaces.length; i++) {
    if (Callback.class.isAssignableFrom(ifaces[i])) {
      type=ifaces[i];
      break;
    }
  }
  TypeMapper mapper=null;
  Class declaring=type.getDeclaringClass();
  if (declaring != null) {
    mapper=Native.getTypeMapper(declaring);
  }
  Method m=getCallbackMethod(callback);
  proxy=new DefaultCallbackProxy(m,mapper);
  Class[] nativeParamTypes=proxy.getParameterTypes();
  if (mapper != null) {
    for (int i=0; i < nativeParamTypes.length; i++) {
      FromNativeConverter rc=mapper.getFromNativeConverter(nativeParamTypes[i]);
      if (rc != null) {
        nativeParamTypes[i]=rc.nativeType();
      }
    }
  }
  for (int i=0; i < nativeParamTypes.length; i++) {
    Class cls=nativeParamTypes[i];
    if (Structure.class.isAssignableFrom(cls)) {
      try {
        cls.newInstance();
      }
 catch (      InstantiationException e) {
        throw new IllegalArgumentException("Can't instantiate " + cls + ": "+ e);
      }
catch (      IllegalAccessException e) {
        throw new IllegalArgumentException("Instantiation of " + cls + " not allowed (is it public?): "+ e);
      }
      nativeParamTypes[i]=Pointer.class;
    }
 else     if (NativeLong.class.isAssignableFrom(cls)) {
      nativeParamTypes[i]=NativeLong.SIZE == 4 ? Integer.class : Long.class;
    }
 else     if (cls == String.class || cls == WString.class) {
      nativeParamTypes[i]=Pointer.class;
    }
 else     if (!isAllowableNativeType(cls)) {
      throw new IllegalArgumentException("Callback argument " + cls + " requires custom type conversion");
    }
  }
  try {
    Method proxyMethod=CallbackProxy.class.getMethod("callback",new Class[]{Object[].class});
    cbstruct=createCallback(proxy,proxyMethod,nativeParamTypes,callingConvention);
  }
 catch (  NoSuchMethodException e) {
    throw new Error("Unexpectedly missing CallbackProxy.callback(Object[])");
  }
}
