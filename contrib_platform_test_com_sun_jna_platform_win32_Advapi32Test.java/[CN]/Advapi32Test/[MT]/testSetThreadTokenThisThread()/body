{
  HANDLEByReference phToken=new HANDLEByReference();
  HANDLEByReference phTokenDup=new HANDLEByReference();
  HANDLEByReference pthreadHandle=new HANDLEByReference();
  pthreadHandle.setValue(Kernel32.INSTANCE.GetCurrentThread());
  if (!Advapi32.INSTANCE.OpenThreadToken(pthreadHandle.getValue(),WinNT.TOKEN_IMPERSONATE | WinNT.TOKEN_QUERY,false,phToken)) {
    assertEquals(W32Errors.ERROR_NO_TOKEN,Kernel32.INSTANCE.GetLastError());
    HANDLE processHandle=Kernel32.INSTANCE.GetCurrentProcess();
    assertTrue(Advapi32.INSTANCE.OpenProcessToken(processHandle,WinNT.TOKEN_DUPLICATE,phToken));
    assertTrue(Advapi32.INSTANCE.DuplicateTokenEx(phToken.getValue(),WinNT.TOKEN_IMPERSONATE,null,WinNT.SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation,WinNT.TOKEN_TYPE.TokenImpersonation,phTokenDup));
    assertTrue(Advapi32.INSTANCE.SetThreadToken(pthreadHandle,phTokenDup.getValue()));
  }
 else {
    assertTrue(Advapi32.INSTANCE.SetThreadToken(pthreadHandle,phToken.getValue()));
  }
  assertTrue(Advapi32.INSTANCE.SetThreadToken(null,null));
  assertTrue(Kernel32.INSTANCE.CloseHandle(phToken.getValue()));
  if (phTokenDup.getValue() != null)   assertTrue(Kernel32.INSTANCE.CloseHandle(phTokenDup.getValue()));
}
